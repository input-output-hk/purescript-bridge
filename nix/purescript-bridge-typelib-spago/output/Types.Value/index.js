// Generated by purs version 0.14.5
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Alternative = require("../Control.Alternative/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Argonaut_Core = require("../Data.Argonaut.Core/index.js");
var Data_Argonaut_Decode_Class = require("../Data.Argonaut.Decode.Class/index.js");
var Data_Argonaut_Decode_Combinators = require("../Data.Argonaut.Decode.Combinators/index.js");
var Data_Argonaut_Decode_Error = require("../Data.Argonaut.Decode.Error/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_BigInt = require("../Data.BigInt/index.js");
var Data_Bitraversable = require("../Data.Bitraversable/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Generic_Rep = require("../Data.Generic.Rep/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Lattice = require("../Data.Lattice/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Map = require("../Data.Map/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Set = require("../Data.Set/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Show_Generic = require("../Data.Show.Generic/index.js");
var Data_These = require("../Data.These/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var FromData = require("../FromData/index.js");
var Serialization_Hash = require("../Serialization.Hash/index.js");
var ToData = require("../ToData/index.js");
var Types_ByteArray = require("../Types.ByteArray/index.js");
var Types_PlutusData = require("../Types.PlutusData/index.js");
var Types_Scripts = require("../Types.Scripts/index.js");
var TokenName = function (x) {
    return x;
};
var CurrencySymbol = function (x) {
    return x;
};
var NonAdaAsset = function (x) {
    return x;
};
var Coin = function (x) {
    return x;
};
var Value = (function () {
    function Value(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Value.create = function (value0) {
        return function (value1) {
            return new Value(value0, value1);
        };
    };
    return Value;
})();
var toDataTokenName = ToData.toDataByteArray;
var toDataCurrencySymbol = ToData.toDataByteArray;
var toDataNonAdaAsset = ToData.toDataMap(toDataCurrencySymbol)(ToData.toDataMap(toDataTokenName)(ToData.toDataBigInt));
var toDataCoin = ToData.toDataBigInt;
var toDataValue = {
    toData: function (v) {
        return ToData.toData(ToData.toDataTuple(toDataCoin)(toDataNonAdaAsset))(new Data_Tuple.Tuple(v.value0, v.value1));
    }
};
var splitCoin = {
    split: function (v) {
        var $132 = Data_Ord.lessThanOrEq(Data_BigInt.ordBigInt)(v)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
        if ($132) {
            return new Data_Tuple.Tuple(Data_Ring.negate(Data_BigInt.ringBigInt)(v), Data_Semiring.zero(Data_BigInt.semiringBigInt));
        };
        return new Data_Tuple.Tuple(Data_Semiring.zero(Data_BigInt.semiringBigInt), v);
    }
};
var showTokenName = {
    show: function (v) {
        return "(TokenName" + (Data_Show.show(Types_ByteArray.showByteArray)(v) + ")");
    }
};
var showCurrencySymbol = {
    show: function (v) {
        return "(CurrencySymbol" + (Data_Show.show(Types_ByteArray.showByteArray)(v) + ")");
    }
};
var showNonAdaAsset = {
    show: function (v) {
        return "(NonAdaAsset" + (Data_Show.show(Data_Map_Internal.showMap(showCurrencySymbol)(Data_Map_Internal.showMap(showTokenName)(Data_BigInt.showBigInt)))(v) + ")");
    }
};
var semigroupCoin = {
    append: function (v) {
        return function (v1) {
            return Data_Semiring.add(Data_BigInt.semiringBigInt)(v)(v1);
        };
    }
};
var ordTokenName = Types_ByteArray.ordByteArray;
var ordCurrencySymbol = Types_ByteArray.ordByteArray;
var newtypeNonAdaAsset_ = {
    Coercible0: function () {
        return undefined;
    }
};
var newtypeCoin_ = {
    Coercible0: function () {
        return undefined;
    }
};
var negateNonAdaAsset = {
    negation: (function () {
        var $318 = Data_Newtype.wrap();
        var $319 = Data_Functor.map(Data_Map_Internal.functorMap)(Data_Functor.map(Data_Map_Internal.functorMap)(Data_Ring.negate(Data_BigInt.ringBigInt)));
        var $320 = Data_Newtype.unwrap();
        return function ($321) {
            return $318($319($320($321)));
        };
    })()
};
var negateCoin = {
    negation: (function () {
        var $322 = Data_Newtype.wrap();
        var $323 = Data_Ring.negate(Data_BigInt.ringBigInt);
        var $324 = Data_Newtype.unwrap();
        return function ($325) {
            return $322($323($324($325)));
        };
    })()
};
var monoidCoin = {
    mempty: Data_Semiring.zero(Data_BigInt.semiringBigInt),
    Semigroup0: function () {
        return semigroupCoin;
    }
};
var meetSemilatticeCoin = {
    meet: function (v) {
        return function (v1) {
            return Data_Ord.min(Data_BigInt.ordBigInt)(v)(v1);
        };
    }
};
var joinSemilatticeCoin = {
    join: function (v) {
        return function (v1) {
            return Data_Ord.max(Data_BigInt.ordBigInt)(v)(v1);
        };
    }
};
var genericValue_ = {
    to: function (x) {
        return new Value(x.value0, x.value1);
    },
    from: function (x) {
        return new Data_Generic_Rep.Product(x.value0, x.value1);
    }
};
var genericCoin_ = {
    to: function (x) {
        return x;
    },
    from: function (x) {
        return x;
    }
};
var showCoin = {
    show: Data_Show_Generic.genericShow(genericCoin_)(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsArgument(Data_BigInt.showBigInt))({
        reflectSymbol: function () {
            return "Coin";
        }
    }))
};
var showValue = {
    show: Data_Show_Generic.genericShow(genericValue_)(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsProduct(Data_Show_Generic.genericShowArgsArgument(showCoin))(Data_Show_Generic.genericShowArgsArgument(showNonAdaAsset)))({
        reflectSymbol: function () {
            return "Value";
        }
    }))
};
var fromDataTokenName = FromData.fromDataByteArray;
var fromDataCurrencySymbol = FromData.fromDataByteArray;
var fromDataNonAdaAsset = FromData.fromDataMap(fromDataCurrencySymbol)(ordCurrencySymbol)(FromData.fromDataMap(fromDataTokenName)(ordTokenName)(FromData.fromDataBigInt));
var fromDataCoin = FromData.fromDataBigInt;
var fromDataValue = {
    fromData: function (v) {
        if (v instanceof Types_PlutusData.List && v.value0.length === 2) {
            return Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Value.create)(FromData.fromData(fromDataCoin)(v["value0"][0])))(FromData.fromData(fromDataNonAdaAsset)(v["value0"][1]));
        };
        return Data_Maybe.Nothing.value;
    }
};
var eqTokenName = Types_ByteArray.eqByteArray;
var eqCurrencySymbol = Types_ByteArray.eqByteArray;
var eqNonAdaAsset = Data_Map_Internal.eqMap(eqCurrencySymbol)(Data_Map_Internal.eqMap(eqTokenName)(Data_BigInt.eqBigInt));
var eqCoin = Data_BigInt.eqBigInt;
var eqValue = {
    eq: function (x) {
        return function (y) {
            return Data_Eq.eq(eqCoin)(x.value0)(y.value0) && Data_Eq.eq(eqNonAdaAsset)(x.value1)(y.value1);
        };
    }
};
var unsafeAdaSymbol = Data_Monoid.mempty(Types_ByteArray.monoidByteArray);
var union = function (dictOrd) {
    return function (l) {
        return function (r) {
            var rs = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(r);
            var ls = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(l);
            var rs$prime = Data_Array.filter(function (v) {
                return !Data_Foldable.any(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v1) {
                    return Data_Eq.eq(dictOrd.Eq0())(v1.value0)(v.value0);
                })(ls);
            })(rs);
            var rs$prime$prime = Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Tuple.functorTuple)(Data_These.That.create))(rs$prime);
            var f = function (a) {
                return function (b$prime) {
                    if (b$prime instanceof Data_Maybe.Nothing) {
                        return new Data_These.This(a);
                    };
                    if (b$prime instanceof Data_Maybe.Just) {
                        return new Data_These.Both(a, b$prime.value0);
                    };
                    throw new Error("Failed pattern match at Types.Value (line 444, column 14 - line 446, column 25): " + [ b$prime.constructor.name ]);
                };
            };
            var ls$prime = Data_Functor.map(Data_Functor.functorArray)(function (v) {
                return new Data_Tuple.Tuple(v.value0, f(v.value1)(Data_Map_Internal.lookup(dictOrd)(v.value0)(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray)(rs))));
            })(ls);
            return Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray)(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ls$prime)(rs$prime$prime));
        };
    };
};
var unionNonAda = function (v) {
    return function (v1) {
        var unBoth = function (k) {
            if (k instanceof Data_These.This) {
                return Data_Functor.map(Data_Map_Internal.functorMap)(Data_These.This.create)(k.value0);
            };
            if (k instanceof Data_These.That) {
                return Data_Functor.map(Data_Map_Internal.functorMap)(Data_These.That.create)(k.value0);
            };
            if (k instanceof Data_These.Both) {
                return union(ordTokenName)(k.value0)(k.value1);
            };
            throw new Error("Failed pattern match at Types.Value (line 475, column 16 - line 478, column 28): " + [ k.constructor.name ]);
        };
        var combined = union(ordCurrencySymbol)(v)(v1);
        return Data_Functor.map(Data_Map_Internal.functorMap)(unBoth)(combined);
    };
};
var unionWithNonAda = function (f) {
    return function (ls) {
        return function (rs) {
            var unBoth = function (k$prime) {
                if (k$prime instanceof Data_These.This) {
                    return f(k$prime.value0)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
                };
                if (k$prime instanceof Data_These.That) {
                    return f(Data_Semiring.zero(Data_BigInt.semiringBigInt))(k$prime.value0);
                };
                if (k$prime instanceof Data_These.Both) {
                    return f(k$prime.value0)(k$prime.value1);
                };
                throw new Error("Failed pattern match at Types.Value (line 495, column 17 - line 498, column 24): " + [ k$prime.constructor.name ]);
            };
            var combined = unionNonAda(ls)(rs);
            return NonAdaAsset(Data_Functor.map(Data_Map_Internal.functorMap)(Data_Functor.map(Data_Map_Internal.functorMap)(unBoth))(combined));
        };
    };
};
var unionWith = function (f) {
    return function (v) {
        return function (v1) {
            return new Value(Coin(f(v.value0)(v1.value0)), unionWithNonAda(f)(v.value1)(v1.value1));
        };
    };
};
var joinSemilatticeNonAdaAsse = {
    join: unionWithNonAda(Data_Ord.max(Data_BigInt.ordBigInt))
};
var joinSemilatticeValue = {
    join: function (v) {
        return function (v1) {
            return new Value(Data_Lattice.join(joinSemilatticeCoin)(v.value0)(v1.value0), Data_Lattice.join(joinSemilatticeNonAdaAsse)(v.value1)(v1.value1));
        };
    }
};
var meetSemilatticeNonAdaAsse = {
    meet: unionWithNonAda(Data_Ord.min(Data_BigInt.ordBigInt))
};
var meetSemilatticeValue = {
    meet: function (v) {
        return function (v1) {
            return new Value(Data_Lattice.meet(meetSemilatticeCoin)(v.value0)(v1.value0), Data_Lattice.meet(meetSemilatticeNonAdaAsse)(v.value1)(v1.value1));
        };
    }
};
var semigroupNonAdaAsset = {
    append: unionWithNonAda(Data_Semiring.add(Data_BigInt.semiringBigInt))
};
var monoidNonAdaAsset = {
    mempty: Data_Map_Internal.empty,
    Semigroup0: function () {
        return semigroupNonAdaAsset;
    }
};
var semigroupValue = {
    append: function (v) {
        return function (v1) {
            return new Value(Data_Semigroup.append(semigroupCoin)(v.value0)(v1.value0), Data_Semigroup.append(semigroupNonAdaAsset)(v.value1)(v1.value1));
        };
    }
};
var monoidValue = {
    mempty: new Value(Data_Monoid.mempty(monoidCoin), Data_Monoid.mempty(monoidNonAdaAsset)),
    Semigroup0: function () {
        return semigroupValue;
    }
};
var split = function (dict) {
    return dict.split;
};
var numCurrencySymbols = function (v) {
    var v1 = Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
    if (!v1) {
        return Data_BigInt.fromInt(1 + Data_Foldable.length(Data_Map_Internal.foldableMap)(Data_Semiring.semiringInt)(v.value1) | 0);
    };
    if (v1) {
        return Data_BigInt.fromInt(Data_Foldable.length(Data_Map_Internal.foldableMap)(Data_Semiring.semiringInt)(v.value1));
    };
    throw new Error("Failed pattern match at Types.Value (line 645, column 3 - line 647, column 41): " + [ v1.constructor.name ]);
};
var negation = function (dict) {
    return dict.negation;
};
var negateValue = {
    negation: function (v) {
        return new Value(negation(negateCoin)(v.value0), negation(negateNonAdaAsset)(v.value1));
    }
};
var mkValue = Value.create;
var mkUnsafeAdaSymbol = function (byteArr) {
    var $217 = Data_Eq.eq(Types_ByteArray.eqByteArray)(byteArr)(Data_Monoid.mempty(Types_ByteArray.monoidByteArray));
    if ($217) {
        return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(unsafeAdaSymbol);
    };
    return Data_Maybe.Nothing.value;
};
var mkTokenName = function (byteArr) {
    var $218 = Types_ByteArray.byteLength(byteArr) <= 32;
    if ($218) {
        return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(byteArr);
    };
    return Data_Maybe.Nothing.value;
};
var mkTokenNames = function (dictTraversable) {
    var $326 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.fromFoldable(ordTokenName)(dictTraversable.Foldable1()));
    var $327 = Data_Traversable.traverse(dictTraversable)(Data_Maybe.applicativeMaybe)(Data_Bitraversable.ltraverse(Data_Bitraversable.bitraversableTuple)(Data_Maybe.applicativeMaybe)(mkTokenName));
    return function ($328) {
        return $326($327($328));
    };
};
var mkSingletonNonAdaAsset = function (curSymbol) {
    return function (tokenName) {
        return function (amount) {
            return NonAdaAsset(Data_Map_Internal.singleton(curSymbol)(Data_Map_Internal.singleton(tokenName)(amount)));
        };
    };
};
var mkNonAdaAsset = NonAdaAsset;
var mkCurrencySymbol = function (byteArr) {
    return Control_Apply.applySecond(Data_Maybe.applyMaybe)(Serialization_Hash.scriptHashFromBytes(byteArr))(Control_Applicative.pure(Data_Maybe.applicativeMaybe)(byteArr));
};
var mkNonAdaAssets$prime = function (dictTraversable) {
    return function (dictTraversable1) {
        var $329 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.fromFoldable(ordCurrencySymbol)(dictTraversable.Foldable1()));
        var $330 = Data_Traversable.traverse(dictTraversable)(Data_Maybe.applicativeMaybe)(Data_Bitraversable.bitraverse(Data_Bitraversable.bitraversableTuple)(Data_Maybe.applicativeMaybe)(mkCurrencySymbol)(mkTokenNames(dictTraversable1)));
        return function ($331) {
            return $329($330($331));
        };
    };
};
var mkNonAdaAssets = function (dictTraversable) {
    return function (dictTraversable1) {
        return function (xs) {
            return Data_Functor.mapFlipped(Data_Maybe.functorMaybe)(mkNonAdaAssets$prime(dictTraversable)(dictTraversable1)(xs))(mkNonAdaAsset);
        };
    };
};
var mkNonAdaAssetsFromTokenMap$prime = function (dictTraversable) {
    var $332 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.fromFoldable(ordCurrencySymbol)(dictTraversable.Foldable1()));
    var $333 = Data_Traversable.traverse(dictTraversable)(Data_Maybe.applicativeMaybe)(Data_Bitraversable.ltraverse(Data_Bitraversable.bitraversableTuple)(Data_Maybe.applicativeMaybe)(mkCurrencySymbol));
    return function ($334) {
        return $332($333($334));
    };
};
var mkNonAdaAssetsFromTokenMap = function (dictTraversable) {
    return function (xs) {
        return Data_Functor.mapFlipped(Data_Maybe.functorMaybe)(mkNonAdaAssetsFromTokenMap$prime(dictTraversable)(xs))(mkNonAdaAsset);
    };
};
var mpsSymbol = function (v) {
    return mkCurrencySymbol(Serialization_Hash.scriptHashToBytes(v));
};
var decodeJsonCurrencySymbol = {
    decodeJson: Data_Argonaut_Core.caseJsonObject(Data_Either.Left.create(new Data_Argonaut_Decode_Error.TypeMismatch("Expected object")))(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)((function () {
        var $335 = Data_Either.note(new Data_Argonaut_Decode_Error.TypeMismatch("Invalid CurrencySymbol"));
        return function ($336) {
            return $335(mkCurrencySymbol($336));
        };
    })())(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)((function () {
        var $337 = Data_Either.note(new Data_Argonaut_Decode_Error.TypeMismatch("Invalid ByteArray"));
        return function ($338) {
            return $337(Types_ByteArray.hexToByteArray($338));
        };
    })())(Data_Function.flip(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonString))("unCurrencySymbol"))))
};
var mkCoin = function ($339) {
    return Coin(Data_BigInt.fromInt($339));
};
var mapThese = function (dictOrd) {
    return function (f) {
        return function (mps) {
            var mps$prime = Data_Functor.map(Data_Map_Internal.functorMap)(f)(mps);
            var f$prime = function (k) {
                return function (v) {
                    return function (v1) {
                        if (v instanceof Data_These.This) {
                            return new Data_Tuple.Tuple(Data_Array.cons(new Data_Tuple.Tuple(k, v.value0))(v1.value0), v1.value1);
                        };
                        if (v instanceof Data_These.That) {
                            return new Data_Tuple.Tuple(v1.value0, Data_Array.cons(new Data_Tuple.Tuple(k, v.value0))(v1.value1));
                        };
                        if (v instanceof Data_These.Both) {
                            return new Data_Tuple.Tuple(Data_Array.cons(new Data_Tuple.Tuple(k, v.value0))(v1.value0), Data_Array.cons(new Data_Tuple.Tuple(k, v.value1))(v1.value1));
                        };
                        throw new Error("Failed pattern match at Types.Value (line 721, column 23 - line 724, column 57): " + [ v.constructor.name ]);
                    };
                };
            };
            return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray))(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray))(Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(f$prime)(new Data_Tuple.Tuple([  ], [  ]))(mps$prime));
        };
    };
};
var splitNonAdaAsset = {
    split: function (v) {
        var splitIntl = function (mp$prime) {
            var v1 = mapThese(ordTokenName)(function (i) {
                var $231 = Data_Ord.lessThanOrEq(Data_BigInt.ordBigInt)(i)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
                if ($231) {
                    return new Data_These.This(Data_Ring.negate(Data_BigInt.ringBigInt)(i));
                };
                return new Data_These.That(i);
            })(mp$prime);
            return new Data_These.Both(v1.value0, v1.value1);
        };
        var v1 = mapThese(ordCurrencySymbol)(splitIntl)(v);
        return new Data_Tuple.Tuple(v1.value0, v1.value1);
    }
};
var splitValue = {
    split: function (v) {
        return Data_Semigroup.append(Data_Tuple.semigroupTuple(semigroupValue)(semigroupValue))(Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Data_Function.flip(Value.create)(Data_Monoid.mempty(monoidNonAdaAsset)))(Data_Function.flip(Value.create)(Data_Monoid.mempty(monoidNonAdaAsset)))(split(splitCoin)(v.value0)))(Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Value.create(Data_Monoid.mempty(monoidCoin)))(Value.create(Data_Monoid.mempty(monoidCoin)))(split(splitNonAdaAsset)(v.value1)));
    }
};
var lovelaceValueOf = Data_Function.flip(function ($340) {
    return Value.create(Coin($340));
})(Data_Monoid.mempty(monoidNonAdaAsset));
var isZero = function (v) {
    return Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Eq.eq(Data_BigInt.eqBigInt)(Data_Semiring.zero(Data_BigInt.semiringBigInt))))(v.value1) && Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
};
var getTokenName = function (v) {
    return v;
};
var getNonAdaAsset$prime = function (v) {
    return v.value1;
};
var getNonAdaAsset = function (v) {
    return v.value1;
};
var getLovelace = function (v) {
    return v;
};
var getCurrencySymbol = function (v) {
    return v;
};
var flattenNonAdaValue = function (v) {
    return Control_Bind.bind(Data_List_Types.bindList)(Data_Map_Internal.toUnfoldable(Data_List_Types.unfoldableList)(v))(function (v1) {
        return Control_Bind.bind(Data_List_Types.bindList)(Data_Map_Internal.toUnfoldable(Data_List_Types.unfoldableList)(v1.value1))(function (v2) {
            return Control_Bind.discard(Control_Bind.discardUnit)(Data_List_Types.bindList)(Control_Alternative.guard(Data_List_Types.alternativeList)(Data_Eq.notEq(Data_BigInt.eqBigInt)(v2.value1)(Data_Semiring.zero(Data_BigInt.semiringBigInt))))(function () {
                return Control_Applicative.pure(Data_List_Types.applicativeList)(new Data_Tuple.Tuple(v1.value0, new Data_Tuple.Tuple(v2.value0, v2.value1)));
            });
        });
    });
};
var filterNonAda = function (v) {
    return new Value(Data_Monoid.mempty(monoidCoin), v.value1);
};
var currencyScriptHash = function (v) {
    return Data_Maybe.fromJust()(Serialization_Hash.scriptHashFromBytes(v));
};
var currencyMPSHash = function ($341) {
    return Types_Scripts.MintingPolicyHash(currencyScriptHash($341));
};
var coinToValue = function (v) {
    return lovelaceValueOf(v);
};
var checkPred = function (f) {
    return function (v) {
        return function (v1) {
            var inner = Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(f);
            return f(new Data_These.Both(v.value0, v1.value0)) && Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(inner)(unionNonAda(v.value1)(v1.value1));
        };
    };
};
var checkBinRel = function (f) {
    return function (l) {
        return function (r) {
            var unThese = function (k$prime) {
                if (k$prime instanceof Data_These.This) {
                    return f(k$prime.value0)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
                };
                if (k$prime instanceof Data_These.That) {
                    return f(Data_Semiring.zero(Data_BigInt.semiringBigInt))(k$prime.value0);
                };
                if (k$prime instanceof Data_These.Both) {
                    return f(k$prime.value0)(k$prime.value1);
                };
                throw new Error("Failed pattern match at Types.Value (line 586, column 18 - line 589, column 24): " + [ k$prime.constructor.name ]);
            };
            return checkPred(unThese)(l)(r);
        };
    };
};
var eq = checkBinRel(Data_Eq.eq(Data_BigInt.eqBigInt));
var geq = checkBinRel(Data_Ord.greaterThanOrEq(Data_BigInt.ordBigInt));
var gt = function (l) {
    return function (r) {
        return !(isZero(l) && isZero(r)) && checkBinRel(Data_Ord.greaterThan(Data_BigInt.ordBigInt))(l)(r);
    };
};
var leq = checkBinRel(Data_Ord.lessThanOrEq(Data_BigInt.ordBigInt));
var lt = function (l) {
    return function (r) {
        return !(isZero(l) && isZero(r)) && checkBinRel(Data_Ord.lessThan(Data_BigInt.ordBigInt))(l)(r);
    };
};
var adaToken = Data_Monoid.mempty(Types_ByteArray.monoidByteArray);
var mkSingletonValue$prime = function (curSymbol) {
    return function (tokenName) {
        return function (amount) {
            var isAdaCs = Data_Eq.eq(eqCurrencySymbol)(curSymbol)(unsafeAdaSymbol);
            return Control_Bind.discard(Control_Bind.discardUnit)(Data_Maybe.bindMaybe)(Control_Alternative.guard(Data_Maybe.alternativeMaybe)(!isAdaCs || isAdaCs && Data_Eq.eq(eqTokenName)(tokenName)(adaToken)))(function () {
                return Control_Applicative.pure(Data_Maybe.applicativeMaybe)((function () {
                    if (isAdaCs) {
                        return new Value(amount, Data_Monoid.mempty(monoidNonAdaAsset));
                    };
                    return Value.create(Data_Monoid.mempty(monoidCoin))(mkSingletonNonAdaAsset(curSymbol)(tokenName)(amount));
                })());
            });
        };
    };
};
var mkSingletonValue = function (curSymbol$prime) {
    return function (tokenName$prime) {
        return function (amount) {
            return Control_Bind.bind(Data_Maybe.bindMaybe)(Control_Alt.alt(Data_Maybe.altMaybe)(mkCurrencySymbol(curSymbol$prime))(mkUnsafeAdaSymbol(curSymbol$prime)))(function (curSymbol) {
                return Control_Bind.bind(Data_Maybe.bindMaybe)(mkTokenName(tokenName$prime))(function (tokenName) {
                    return mkSingletonValue$prime(curSymbol)(tokenName)(amount);
                });
            });
        };
    };
};
var unflattenValue = function (v) {
    return mkSingletonValue$prime(v.value0)(v.value1.value0)(v.value1.value1);
};
var unsafeAllTokenNames$prime = function (v) {
    var nonAdaUnion = Data_Map_Internal.unions(ordTokenName)(Data_List_Types.foldableList)(Data_Map_Internal.values(v.value1));
    var v1 = Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
    if (!v1) {
        return nonAdaUnion;
    };
    if (v1) {
        return Data_Map_Internal.union(ordTokenName)(Data_Map_Internal.singleton(adaToken)(v.value0))(nonAdaUnion);
    };
    throw new Error("Failed pattern match at Types.Value (line 656, column 5 - line 658, column 71): " + [ v1.constructor.name ]);
};
var numTokenNames = (function () {
    var $342 = Data_Foldable.length(Data_Map_Internal.foldableMap)(Data_BigInt.semiringBigInt);
    return function ($343) {
        return $342(unsafeAllTokenNames$prime($343));
    };
})();
var unsafeAllTokenNames = function ($344) {
    return Data_Map.keys(unsafeAllTokenNames$prime($344));
};
var sumTokenNameLengths = (function () {
    var lenAdd = function (c) {
        return function (a) {
            return Data_Semiring.add(Data_BigInt.semiringBigInt)(c)(Data_BigInt.fromInt(Types_ByteArray.byteLength(getTokenName(a))));
        };
    };
    var $345 = Data_Foldable.foldl(Data_Set.foldableSet)(lenAdd)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
    return function ($346) {
        return $345(unsafeAllTokenNames($346));
    };
})();
var unsafeFlattenValue = function (v) {
    var flattenedNonAda = flattenNonAdaValue(v.value1);
    var v1 = Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
    if (v1) {
        return flattenedNonAda;
    };
    if (!v1) {
        return new Data_List_Types.Cons(new Data_Tuple.Tuple(unsafeAdaSymbol, new Data_Tuple.Tuple(adaToken, v.value0)), flattenedNonAda);
    };
    throw new Error("Failed pattern match at Types.Value (line 529, column 5 - line 531, column 76): " + [ v1.constructor.name ]);
};
var isAdaOnly = function (v) {
    var v1 = unsafeFlattenValue(v);
    if (v1 instanceof Data_List_Types.Cons && v1.value1 instanceof Data_List_Types.Nil) {
        return Data_Eq.eq(eqCurrencySymbol)(v1.value0.value0)(unsafeAdaSymbol) && Data_Eq.eq(eqTokenName)(v1.value0.value1.value0)(adaToken);
    };
    return false;
};
var isPos = (function () {
    var $347 = Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v) {
        return Data_Ord.greaterThan(Data_BigInt.ordBigInt)(v.value1.value1)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
    });
    return function ($348) {
        return $347(unsafeFlattenValue($348));
    };
})();
var minus = function (x) {
    return function (y) {
        var negativeValues = Data_Functor.mapFlipped(Data_List_Types.functorList)(unsafeFlattenValue(y))(function (v) {
            return new Data_Tuple.Tuple(v.value0, new Data_Tuple.Tuple(v.value1.value0, Data_Ring.negate(Data_BigInt.ringBigInt)(v.value1.value1)));
        });
        return Control_Bind.bind(Data_Maybe.bindMaybe)(Data_Traversable.traverse(Data_List_Types.traversableList)(Data_Maybe.applicativeMaybe)(unflattenValue)(negativeValues))(function (y$prime) {
            return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(Data_Semigroup.append(semigroupValue)(x)(Data_Foldable.fold(Data_List_Types.foldableList)(monoidValue)(y$prime)));
        });
    };
};
var unsafeIsAda = function (curSymbol) {
    return function (tokenName) {
        return Data_Eq.eq(eqCurrencySymbol)(curSymbol)(unsafeAdaSymbol) && Data_Eq.eq(eqTokenName)(tokenName)(adaToken);
    };
};
var valueOf = function (v) {
    return function (curSymbol) {
        return function (tokenName) {
            var v1 = unsafeIsAda(curSymbol)(tokenName);
            if (!v1) {
                var v2 = Data_Map_Internal.lookup(ordCurrencySymbol)(curSymbol)(v.value1);
                if (v2 instanceof Data_Maybe.Nothing) {
                    return Data_Semiring.zero(Data_BigInt.semiringBigInt);
                };
                if (v2 instanceof Data_Maybe.Just) {
                    var v3 = Data_Map_Internal.lookup(ordTokenName)(tokenName)(v2.value0);
                    if (v3 instanceof Data_Maybe.Nothing) {
                        return Data_Semiring.zero(Data_BigInt.semiringBigInt);
                    };
                    if (v3 instanceof Data_Maybe.Just) {
                        return v3.value0;
                    };
                    throw new Error("Failed pattern match at Types.Value (line 636, column 19 - line 638, column 22): " + [ v3.constructor.name ]);
                };
                throw new Error("Failed pattern match at Types.Value (line 634, column 7 - line 638, column 22): " + [ v2.constructor.name ]);
            };
            if (v1) {
                return v.value0;
            };
            throw new Error("Failed pattern match at Types.Value (line 632, column 3 - line 639, column 22): " + [ v1.constructor.name ]);
        };
    };
};
var valueToCoin$prime = function (v) {
    return valueOf(v)(unsafeAdaSymbol)(adaToken);
};
var valueToCoin = function ($349) {
    return Coin(valueToCoin$prime($349));
};
module.exports = {
    Coin: Coin,
    NonAdaAsset: NonAdaAsset,
    Value: Value,
    adaToken: adaToken,
    coinToValue: coinToValue,
    currencyMPSHash: currencyMPSHash,
    eq: eq,
    filterNonAda: filterNonAda,
    geq: geq,
    getCurrencySymbol: getCurrencySymbol,
    getLovelace: getLovelace,
    getNonAdaAsset: getNonAdaAsset,
    "getNonAdaAsset'": getNonAdaAsset$prime,
    getTokenName: getTokenName,
    gt: gt,
    isAdaOnly: isAdaOnly,
    isPos: isPos,
    isZero: isZero,
    leq: leq,
    lovelaceValueOf: lovelaceValueOf,
    lt: lt,
    minus: minus,
    mkCoin: mkCoin,
    mkCurrencySymbol: mkCurrencySymbol,
    mkNonAdaAsset: mkNonAdaAsset,
    mkNonAdaAssets: mkNonAdaAssets,
    mkNonAdaAssetsFromTokenMap: mkNonAdaAssetsFromTokenMap,
    mkSingletonNonAdaAsset: mkSingletonNonAdaAsset,
    mkSingletonValue: mkSingletonValue,
    "mkSingletonValue'": mkSingletonValue$prime,
    mkTokenName: mkTokenName,
    mkTokenNames: mkTokenNames,
    mkValue: mkValue,
    mpsSymbol: mpsSymbol,
    negation: negation,
    numCurrencySymbols: numCurrencySymbols,
    numTokenNames: numTokenNames,
    split: split,
    sumTokenNameLengths: sumTokenNameLengths,
    unionWith: unionWith,
    unionWithNonAda: unionWithNonAda,
    valueOf: valueOf,
    valueToCoin: valueToCoin,
    "valueToCoin'": valueToCoin$prime,
    genericCoin_: genericCoin_,
    newtypeCoin_: newtypeCoin_,
    eqCoin: eqCoin,
    fromDataCoin: fromDataCoin,
    toDataCoin: toDataCoin,
    showCoin: showCoin,
    semigroupCoin: semigroupCoin,
    monoidCoin: monoidCoin,
    joinSemilatticeCoin: joinSemilatticeCoin,
    meetSemilatticeCoin: meetSemilatticeCoin,
    negateCoin: negateCoin,
    splitCoin: splitCoin,
    eqCurrencySymbol: eqCurrencySymbol,
    fromDataCurrencySymbol: fromDataCurrencySymbol,
    ordCurrencySymbol: ordCurrencySymbol,
    toDataCurrencySymbol: toDataCurrencySymbol,
    showCurrencySymbol: showCurrencySymbol,
    decodeJsonCurrencySymbol: decodeJsonCurrencySymbol,
    eqTokenName: eqTokenName,
    fromDataTokenName: fromDataTokenName,
    ordTokenName: ordTokenName,
    toDataTokenName: toDataTokenName,
    showTokenName: showTokenName,
    newtypeNonAdaAsset_: newtypeNonAdaAsset_,
    fromDataNonAdaAsset: fromDataNonAdaAsset,
    eqNonAdaAsset: eqNonAdaAsset,
    toDataNonAdaAsset: toDataNonAdaAsset,
    showNonAdaAsset: showNonAdaAsset,
    semigroupNonAdaAsset: semigroupNonAdaAsset,
    monoidNonAdaAsset: monoidNonAdaAsset,
    joinSemilatticeNonAdaAsse: joinSemilatticeNonAdaAsse,
    meetSemilatticeNonAdaAsse: meetSemilatticeNonAdaAsse,
    negateNonAdaAsset: negateNonAdaAsset,
    splitNonAdaAsset: splitNonAdaAsset,
    genericValue_: genericValue_,
    eqValue: eqValue,
    showValue: showValue,
    semigroupValue: semigroupValue,
    monoidValue: monoidValue,
    joinSemilatticeValue: joinSemilatticeValue,
    meetSemilatticeValue: meetSemilatticeValue,
    negateValue: negateValue,
    splitValue: splitValue,
    fromDataValue: fromDataValue,
    toDataValue: toDataValue
};
