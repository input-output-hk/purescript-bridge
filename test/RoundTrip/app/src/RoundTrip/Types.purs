-- File auto generated by purescript-bridge! --
module RoundTrip.Types where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut.Core (jsonNull)
import Data.Argonaut.Decode (class DecodeJson, decodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>), decode, null)
import Data.Argonaut.Encode (class EncodeJson, encodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<), encode, null)
import Data.Either (Either)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe, Maybe(Nothing, Just))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple (Tuple(Tuple))
import Data.Tuple.Nested ((/\))
import FromData (class FromData, genericFromData)
import ToData (class ToData, genericToData)
import Type.Proxy (Proxy(Proxy))
import TypeLevel.DataSchema (ApPCons, Field, I, Id, IxK, MkField, MkField_, MkIxK, MkIxK_, PCons, PNil, PSchema, class HasPlutusSchema, type (:+), type (:=), type (@@))
import TypeLevel.Nat (S, Z)
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype ANewtype = ANewtype Boolean

derive instance Eq ANewtype

instance Show ANewtype where
  show a = genericShow a

instance EncodeJson ANewtype where
  encodeJson = defer \_ -> E.encode $ unwrap >$< E.value

instance DecodeJson ANewtype where
  decodeJson = defer \_ -> D.decode $ (ANewtype <$> D.value)

derive instance Generic ANewtype _

derive instance Newtype ANewtype _



derive newtype instance ToData ANewtype

derive newtype instance FromData ANewtype

--------------------------------------------------------------------------------

_ANewtype :: Iso' ANewtype Boolean
_ANewtype = _Newtype

--------------------------------------------------------------------------------

newtype ANewtypeRec = ANewtypeRec ANewtype

derive instance Eq ANewtypeRec

instance Show ANewtypeRec where
  show a = genericShow a

instance EncodeJson ANewtypeRec where
  encodeJson = defer \_ -> E.encode $ unwrap >$< E.value

instance DecodeJson ANewtypeRec where
  decodeJson = defer \_ -> D.decode $ (ANewtypeRec <$> D.value)

derive instance Generic ANewtypeRec _

derive instance Newtype ANewtypeRec _



derive newtype instance ToData ANewtypeRec

derive newtype instance FromData ANewtypeRec

--------------------------------------------------------------------------------

_ANewtypeRec :: Iso' ANewtypeRec ANewtype
_ANewtypeRec = _Newtype

--------------------------------------------------------------------------------

newtype ARecord = ARecord
  { field1 :: Boolean
  , field2 :: Either Boolean (Array Boolean)
  , field3 :: Maybe Boolean
  }

derive instance Eq ARecord

instance Show ARecord where
  show a = genericShow a

instance EncodeJson ARecord where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { field1: E.value :: _ Boolean
                                                   , field2: (E.either E.value E.value) :: _ (Either Boolean (Array Boolean))
                                                   , field3: (E.maybe E.value) :: _ (Maybe Boolean)
                                                   })

instance DecodeJson ARecord where
  decodeJson = defer \_ -> D.decode $ (ARecord <$> D.record "ARecord"
      { field1: D.value :: _ Boolean
      , field2: (D.either D.value D.value) :: _ (Either Boolean (Array Boolean))
      , field3: (D.maybe D.value) :: _ (Maybe Boolean)
      })

derive instance Generic ARecord _

derive instance Newtype ARecord _

instance HasPlutusSchema ARecord
  ("ARecord" :=
     ("field1" := I Boolean
     :+ "field2" := I (Either Boolean (Array Boolean))
     :+ "field3" := I (Maybe Boolean)
     :+ PNil)
   @@ (Z)
  :+ PNil)

instance ToData ARecord where
  toData x = genericToData x

instance FromData ARecord where
  fromData x = genericFromData x

--------------------------------------------------------------------------------

_ARecord :: Iso' ARecord {field1 :: Boolean, field2 :: Either Boolean (Array Boolean), field3 :: Maybe Boolean}
_ARecord = _Newtype

--------------------------------------------------------------------------------

data ASum
  = ASumNT ANewtype
  | ASumNTRec ANewtypeRec
  | ASumRec ARecord

derive instance Eq ASum

instance Show ASum where
  show a = genericShow a

instance EncodeJson ASum where
  encodeJson = defer \_ -> case _ of
    ASumNT a -> E.encodeTagged "ASumNT" a E.value
    ASumNTRec a -> E.encodeTagged "ASumNTRec" a E.value
    ASumRec a -> E.encodeTagged "ASumRec" a E.value

instance DecodeJson ASum where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "ASum" $ Map.fromFoldable
      [ "ASumNT" /\ D.content (ASumNT <$> D.value)
      , "ASumNTRec" /\ D.content (ASumNTRec <$> D.value)
      , "ASumRec" /\ D.content (ASumRec <$> D.value)
      ]

derive instance Generic ASum _

instance HasPlutusSchema ASum
  ("ASumNT" := PNil
   @@ (Z)
  :+ "ASumNTRec" := PNil
     @@ (S (Z))
  :+ "ASumRec" := PNil
     @@ (S (S (Z)))
  :+ PNil)

instance ToData ASum where
  toData x = genericToData x

instance FromData ASum where
  fromData x = genericFromData x

--------------------------------------------------------------------------------

_ASumNT :: Prism' ASum ANewtype
_ASumNT = prism' ASumNT case _ of
  (ASumNT a) -> Just a
  _ -> Nothing

_ASumNTRec :: Prism' ASum ANewtypeRec
_ASumNTRec = prism' ASumNTRec case _ of
  (ASumNTRec a) -> Just a
  _ -> Nothing

_ASumRec :: Prism' ASum ARecord
_ASumRec = prism' ASumRec case _ of
  (ASumRec a) -> Just a
  _ -> Nothing
